## 线程安全

### 概念

  当多个线程访问某一个类（对象或方法）时，这个类始终都能表现出正确的行为，那个这个类（对象或方法）就是线程安全的。
  
### `synchronized`锁

Java中，`synchronized`可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。

当多个线程访问带有`synchronized`的方法时，以排队的方式进行处理（CPU分配的先后顺序），一个线程要执行`synchronized`修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行`synchronized`代码里的内容；如果拿不到锁，就这个线程就会不断尝试去获得这把锁，直到拿到为止，而且是多个线程同时去竞争这把锁。

关键字`synchronized`取得的锁都是对象锁，而不是把一段代码（方法）当做锁，如果多个线程分别持有不同对象的锁，那么多个线程各自获得的就是多个不同的锁，它们互不影响。

有一种情况则是相同的锁，就是在静态方法上加`synchronized`，表示锁定`.class`类，类级别的锁。

synchronized同步的概念就是共享，如果不是共享的资源，就没有必要进行同步。
asynchronized异步的概念就是独立，独立相互之间不受到任何制约。

同步的目的就是为了线程安全，线程安全，需要满足两个特性：
* 原子性（同步）。
* 可见性。

### 原子性

在对一个对象的方法加锁的时候，需要考虑业务的整体性，即为需要同步的方法加synchronized同步关键字，保证业务的原子性（ACID）。

ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

### synchronized锁重入

synchronized拥有锁重入的功能，也就是在使用synchronized时，一个线程得到了一个对象的锁后，再次请求此对象时可以再次得到该对象的锁。出现异常，锁自动释放。

对于web应用程序，异常释放的情况，如果不及时处理，很可能对你的应用程序业务逻辑产生严重的错误。例如，现在正在执行一个队列任务，很多对象都去在等待一个对象正确执行完毕后再去释放锁，但是第一个对象由于异常的出现，导致业务逻辑没有正常执行完毕，就释放了锁，那么可想而知，后续的对象执行的都是错误的逻辑。
