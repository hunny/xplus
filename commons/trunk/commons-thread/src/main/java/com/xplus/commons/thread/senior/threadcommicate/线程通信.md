## 线程通信

线程通信概念：线程是操作系统中独立的个体，但是这些个体如果不经过特殊的处理就不能成为一个整体，线程间的通信就成为整体的必用方式之一。当线程存在通信指挥，系统间的交互性会理强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督。

使用wait/notify方法实现线程间的通信。
1. wait/notify必须配合synchronized关键字使用。
2. wait方法释放锁，notify方法不释放锁。

## 说明

* 1.wait、notify以及notifyAll都是Object对象的方法，他们必须在被 synchronized 同步的方法或代码块中调用，否则会报错。
* 2. 调用wait方法会使该线程进入等待状态，并且会释放被同步对象的锁。
* 3. notify操作可以唤醒一个因执行wait而处于阻塞状态的线程，使其进入就绪状态，被唤醒的线程会去尝试着获取对象锁，然后执行wait之后的代码。如果发出notify操作时，没有线程处于阻塞状态，那么该命令会忽略。注意执行notify并不会马上释放对象锁，会等到执行完该同步方法或同步代码块后才释放，下面会有例子来证明。
notify方法可以随机唤醒等待队列中等待同一共享资源的“一个”线程，使其退出等待队列进入可运行状态。
* 4. notifyAll方法可以唤醒等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程优先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现。
测试在调用notify方法之后并不会马上释放对象锁，而是在执行完同步方法或同步方法块的时候才会释放。

## wait(), notify(),sleep详解

在JAVA中，是没有类似于PV操作、进程互斥等相关的方法的。JAVA的进程同步是通过synchronized()来实现的，需要说明的是，JAVA的synchronized()方法类似于操作系统概念中的互斥内存块，在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别了，synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了。

Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。

## 关于锁

1.调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。

2.调用同一个类中的静态同步方法的线程将彼此阻塞，他们都所锁在同一个class对象上


